# 일관성 있는 협력
- 객체지향 설계의 목표는 적절한 책임을 수행하는 객체들의 협력을 기반으로써 결합도가 낮고 재사용 가능한 코드 구조를 창조하는것.
- 객체들의 협력 구조가 서로 다른 경우 코드 이해가 어렵고 설계의 일관성이 무너지게 된다.
- 객체들의 협력이 전체적으로 일관성 있고 유사한 패턴을 사용하자.

<br>

## 설계에 일관성 부여하기
- 일관성 있는 설계를 위해 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해보는 것.
- 디자인 패턴은 특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 설계 템플릿이다.
    - 물론 모든 경우에 적합한 패턴을 적용할 수 없다.
- 협력을 일관성 있게 만들기 위해서는
1. 변하는 개념을 변하지 않는 개념으로부터 분리하라!
    - 새로운 요구사항이 있을 때마다 바뀌는 부분이 있다면 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리하라.
2. 변하는 개념을 캡슐화하라!
    - 바뀌는 부분을 따로 뽑아서 캡슐화한다면, 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 고치거나 확장이 가능하다.
- 변경 주기가 서로 다른 코드들이 한 클래스에 뭉쳐있게 된다면, 추가시 기존 코드를 수정해야한다.
    - 절차지향
- 객체지향은 조건 로직을 객체 사이의 이동으로 바꾸는 것.
    - **`객체지향 코드는 조건을 판단하지 않는다. 단지 다음 객체로 이동할 뿐이다.`**
    - 다형성은 조건 로직을 객체 사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법이다.
    
```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Money calculateMovieFee(Screening screening){
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
/* 
    Movie 는 discountPolicy 가 자신의 요청을 처리해줄 것이라고 믿고 메시지를 전송할 뿐이다.
    Movie 는 현재의 할인 정책이 어떤 종류인지 판단하지 않는다. 단지 DiscountPolicy 로 향하는 참조를 통해 메세지를 전달할 뿐이다.
 */


public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions = new ArrayList<>();

    public Money calculateDiscountAmount(Screening screening){
        for (DiscountCondition each : conditions){
            if (each.isSatisfiedBy(screening)){
                return getDiscountAmount(screening);
            }
        }
        return screening.getMovieFee();
    }
}
/*
    DiscountPolicy 역시 할인 조건의 종류를 판단하지 않는다. 단지 DiscountCondition 으로 향하는 참조를 통해 메세지를 전달할 뿐이다.
 */
```

<br>

- 조건 로직을 객체 사이의 이동으로 대체하기 위해서는 커다란 클래스를 작은 클래스들로 분리해야 한다.
    - 작은 클래스들로 분리되면 객체들 사이의 협력 패언에 일관성을 부여하기가 쉬워진다.
    - 작은 클래스들이 자연스럽게 **역할**이라는 추상화로 묶이게 되고 역할 사이에 협력 방식이 일관성을 유지하게 된다.
- 클래스 분리시 해당 기준으로 판단하자.
    - **`변경의 이유와 주기`**
    - 클래스는 단 하나의 이유에서만 변경돼야 하고, SRP 원칙을 따르도록 분리되어야 한다.

<br>
<br>

- 협력을 일관성 있게 만들기 위해서는 
1. 변하는 개념을 분리해서 타입 계층으로 만든다.
    - 책의 예제에서 할인 정책과 할인 조건의 타입을 체크하는 하나하나의 조건문을 개별적인 객체로 분리했고, <br>
      일관성 있게 협력하기 위해 타입 계층을 구성하여 역할을 추상 클래스와 인터페이스로 구현하였고 <br>
      결과적으로 변하는 개념, 부분들의 공통적인 행동을 추상화 후 서브타입으로 분리하여 변하지 않는 부분이 이 추상화에만 의존하도록 하여 변경으로부터 캡슐화
2. 변하는 개념을 캡슐화 하라.
    - Movie 가 알고 있는 사실은 협력하는 객체가 단지 DiscountPolicy 클래스의 인터페이스에 정의된 calculateDiscountAmount 메세지를 이해할 수 있다는 것 뿐이다. <br> 
      메세지 수신자 타입은 Movie 에 대해 완벽히 캡슐화되었다. 구현한 타입 계층을 변하지 않는 부분에 합성한다. <br>
      변하지 않는 부분은 변하는 부분의 구체적인 종류에 대해서 알지 못하게 된다.

### 캡슐화 다시 살펴보기
- 보통 캡슐화라고 하면 `데이터 은닉`을 떠올린다.
    - 데이터 은닉이란 오직 외부에 공개된 메서드를 통해서만 객체의 내부를 접근할 수 있게 제한하여 구현을 숨기는 기법
- **캡슐화는 데이터 은닉 이상의 개념이다.**
- **`캡슐화란 변하는 어떤 것이든 감추는 것`**
    - 단순히 데이터만 감추는 것이 아닌 SW 안에서 변할 수 있는 어떤 개념이라도 감추는 것이다.
- 캡슐화는 다양한 종류가 있다.
1. 데이터 캡슐화
    - 클래스 내부에서 관리하는 데이터를 캡슐화한다.
2. 메서드 캡슐화
    - 클래스의 외부에서는 이 메서드에 직접 접근할 수 없고 클래스 내부와 서브 클래스에서만 접근이 가능하다.
3. 객체 캡슐화
    - 객체와 객체 사이의 관계를 캡슐화한다. (합성)
4. 서브타입 캡슐화
    - 추상화로 서브 타입의 종류를 감추고 캡슐화하고 있기 때문에 다형성의 기반이 된다.

<br>
<br>

## 일관성 있는 기본 정책 구현하기
- 변하는 규칙으로 부터 변하는 적용 조건을 분리해야 한다.
