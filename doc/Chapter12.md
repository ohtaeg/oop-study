# 다형성
- 이번 챕터를 통해 다음을 알아가본다.
    - 상속의 관점에서 다형성이 구현되는 기술적인 부분 (매개변수, 포함, 오버로딩, 강제)
    - 다형성이 런타임 시점에서 메시지를 처리하기 위한 적합한 메서드를 동적으로 탐색하는 과정
    - 상속이 외부로부터 호출된 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층 형태로 구현했다는 사실
- 상속을 사용하면 변경하기 어렵고 유연하지 못한 설계할 확률이 높아진다.
- 상속은 **코드 재사용이 아니라 타입 계층을 구조화하기 위해** 사용한다.
    - **자식 클래스와 부모 클래스를 동일한 개념적인 범주로 묶어 is - a 관계를 만들기 위해 사용**
- 상속을 사용하면 변경하기 어렵고 유연하지 못한 설계할 확률이 높아진다.
- 상속은 **코드 재사용이 아니라 타입 계층을 구조화하기 위해** 사용한다.
    - **자식 클래스와 부모 클래스를 동일한 개념적인 범주로 묶어 is - a 관계를 만들기 위해 사용**
- 이번 챕터를 통해 다음을 알아가본다.
    - 상속의 관점에서 다형성이 구현되는 기술적인 부분
    - 다형성이 런타임에 메시지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정
    - 상속이 호출되는 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층 형태로 구현했다는 사실

## 01. 다형성
- 다형성이란 많은 형태를 가질 수 있는 능력을 의미
- OOP에서 다형성은 다음과 같이 분류할 수 있다.
```      
       유니버셜  -  매개변수
        /      ㄴ 포함    
다형성  -
        \
        임시    -  오버로딩
      (Ad hoc) ㄴ  깅제
```
- 매개변수 다형성
    - 제네릭과 관련이 있는 다형성
    - 클래스의 인스턴스 변수나 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체 타입이 정해지는 방식
    - List는 element를 임의의 타입변수 T로 지정 후 실제 인스턴스 생성시 T를 구체적인 타입으로 지정한다.
    - 오버로딩 + 매개변수 다형성 문제는 챕터2에 마지막 부분을 참고하자.
- 오버로딩 다형성
    - 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
- 강제 다형성 
    - 동일한 연산자를 통해 다양한 타입으로 강제 형변환되어 사용할 수 있는 방식
    - 이항 연산자인 '+'는 피연산자가 모두 정수일 경우 덧셈을 수행하지만, 정수 + 문자열인 경우 정수를 문자열로 강제 형변환 후 연결 연산자로 동작한다.              
- 포함 다형성
    - 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력
    - 서브타입 다형성이라고도 불린다.
    - 일반적으로 사용하는 OOP 관점에서의 다형성을 뜻한다. 포함 다형성을 구현하는 가장 일반적인 방법은 상속을 사용하는 것
        ```java
        public class Movie {
            private DiscountPolicy discountPolicy;
      
            public Money calculateMovieFee(Screening screening) {
                return fee.minus(discountPolicy.calculateDiscountAmount(screening)); 
            }
        }
        ```
    - 포함 다형성을 위해 상속을 사용하는 큰 이유는 상속 계층 안에서 어떤 메시지를 수행할지 탐색하는 구조를 제공 
    - 객체가 메시지를 수신하면 메시지를 처리할 메서드를 상속 계층 안에서 탐색한다.
    - 실행할 메서드의 선택하는 기준은 상속 계층의 구성에 따라 달라진다.
    - 이번 장의 목표는 포함 다형성 관점에서 런타임시점에 상속 계층 안에서 적절한 메서드를 선택하는 방법을 이해한다.
- 오버로딩 다형성
    - 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
- 강제 다형성 
    - 동일한 연산자를 통해 다양한 타입으로 강제 형변환되어 사용할 수 있는 방식
    - 이항 연산자인 '+'는 피연산자가 모두 정수일 경우 덧셈을 수행하지만, 정수 + 문자열인 경우 정수를 문자열로 강제 형변환 후 연결 연산자로 동작한다.              
    
<br>

## 02. 상속의 양면성
- 데이터와 행동 관점에서 바라보면 부모의 데이터와 행동을 자식 클래스에게 자동적으로 공유하는 재사용 메커니즘으로 보일 수 있다.
- 상속은 재사용이 아닌 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.
- 단순히 재활용을 목적으로하는 상속은 유지보수에 큰 어려움을 야기할 확률이 높다. 이러한 문제를 피할 수 있는 방법은 상속의 메커니즘을 이해하는 데 필요한 개념을 알아봐야 한다.
    - 업캐스팅
    - 동적 바인딩
    - 동적 메서드 탐색
    - this 참조
    - super 참조
1. 데이터 관점의 상속
    - 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함한다.
2. 행동 관점의 상속
    - 데이터뿐만 아니라 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함한다.
    - 외부에서 부모 클래스의 인스턴스에 전송할 수 있는 모든 메세지는 자식 클래스의 인스턴스에도 전송할 수 있다.

- 동일한 Lecture 타입을 참조하고 동일한 evaluate 메세지를 전송하는 동일한 코드에서 서로 다른 클래스에 구현된 메서드를 실행하고 있다.
- 예제 코드가 말하는 내용은 실제로 메세지를 수신한 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다는걸 말하는데 이게 가능한 메커니즘이 두개가 있다.
1. 업캐스팅
    - 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는것이 가능
2. 동적 바인딩
    - 메시지를 처리할 적절한 메서드를 컴파일이 아닌 런타임 시점에 결정 되는것

<br>

### 업캐스팅
- 부모 클래스 타입으로 선언된 참조 변수에 자식 클래스의 인스턴스를 할당하는 것
- 컴파일러는 명시적인 타입 변환 없이도 자식 클래스가 부모 클래스를 대체할 수 있도록 허용한다.
- 이런 특성을 이용해 부모 클래스 타입에 자식 클래스 대입을 허용한다.
    - Lecture lecture = (Lecture 생략) new GradeLecture(); // 대입
    ```
    public class Professor {
        // 메서드 파라미터
        public Professor (String name, Lecture lecture) { }  
    }
    Professor professor = new Professor("다익스트라", new GradeLecture(...));
    ```
- 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용하더라도 메시지 처리하는데 문제 없다.
    - 업캐스팅을 통해 미래의 자식 클래스들도 협력에 참여할 수 있다.
- 반대로 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 `명시적인 타입 캐스팅`이 필요한데 이걸 다운 캐스팅이라 한다.
- 다운 캐스팅 예)
```java
interface SmartPhone {
}

class Iphone implements SmartPhone {
}

class Galaxy implements SmartPhone {
}

public class Game {
    public void play(IPhone phone) {
        System.out.println("iphone play [" + phone.getClass().getSimpleName() + "]");
    }

    public void play(Galaxy phone) {
        System.out.println("galaxy play [" + phone.getClass().getSimpleName() + "]");
    }

    public static void main(String[] args) {
        List<SmartPhone> phoneList = Arrays.asList(new IPhone(), new Galaxy());
    }
}
/*
자바는 하위 타입으로의 묵시적 형변환을 지원하지 않기때문에 명시적으로 형변환을 해야한다. 
하지만 2개의 요소가 서로 타입이 다르므로 명시적 형변환을 하려면 반복문을 사용할 수 없다. 
제네릭같은 방법을 이용한다고 하더라도 구현체마다 다른 행동을 해야하므로 하나의 메서드로 모으는건 의미가 없다.
 */
```
### 동적 바인딩
- 선언된 참조 변수 타입이 아니라 메시지를 수신하는 인스턴스 타입에 따라 실행되는 메서드가 결정이 된다.
    - Lecture lecture = new GradeLecture();
    - lecture.evaluate();
- 메시지를 처리할 적절한 메서드를 **컴파일 시점이 아닌 런타임 시점에 결정되는 것을 동적 바인딩**이라고 부른다.
- 업캐스팅과 동적 메서드 탐색은 코드를 변경하지 않고도 기능을 추가할 수 있게 해주어 OCP 원칙 의도와도 일치한다. 
- OCP 원칙은 의존 관계를 구조화 하는 방법을 설명하는 것이다.
    - OCP 원칙이 목적이라면 업캐스팅과 동적 바인딩은 목적에 이르는 방법
1. 메서드 오버라이딩
    - 자식 클래스 안에 상속 받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것이다.
2. 메서드 오버로딩
    - 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것이다.
- OOP 에서는 어떤 규칙으로 인해 메서드 전송과 메서드 호출을 바인딩 할까?

<br>

### 동적 메서드 탐색
- OOP는 다음과 같이 실행할 메서드를 탐색한다.
    1. 메시지를 수신한 객체는 적합한 메서드가 존재하면 실행, 못찾았다면 부모를 탐색 (메서드 탐색은 자식 -> 부모 방향으로 진행된다.)
    2. 상속 최상위까지 탐색했는데 존재하지 않는다면 예외
- 메서드 탐색과 메서드 호출은 의미가 명확하게 다르다.
    - 메서드 호출은 그 메서드를 실행해 달라는 의미이며
    - 메서드 탐색은 그 메서드로 부터 메세지를 이해할 수 있는 부모에게 메세지를 위임
- 위의 설명을 종합해보면 동적 메서드 탐색은 두가지 원리로 구성된다.
1. 자동적인 메시지 위임
    - 자신이 이해할 수 없는 메시지를 상위, 부모에게 위임
    - 이런 관점에서 상속 계층을 정의하는건 탐색 경로를 정의하는 것과 동일
2. 동적인 문맥을 사용
    - 메시지 수신시, 실제로 어떤 객체가 메서드를 실행할지 결정하는 것은 런타임 시점에서 수행
    - 이때 객체가 어떤 타입인지 추적해야하는데, 이 객체의 타입에 따라 문맥이 동적으로 결정된다.
    - **문맥을 동적으로 결정하는것은 메시지를 수신한 객체를 가르키는 this 참조이다.**

Q. p.420 첫줄에 자바는 정적 타입 언어라고 설명되어있는데 정적(컴파일)이면서 동적(런타임)인 언어라고 표현하는게 맞지 않을까?

### this 참조
- 동적 메서드 탐색시 컴파일러는 this 참조라는 임시 변수를 생성하여 `메시지를 수신한 객체를 가리키도록 설정`한다.
- 메시지를 처리할 객체를 탐색하기 위해 this 참조가 가리키는 메모리로 이동 후 class 포인터를 따라 이동하여 자식 클래스에서 부모 클래스 방향으로 탐색을 진행.
    - p.409
- this 참조라는 것은 업캐스팅과 동적 바인딩이라는 특성을 이용하여 런타임 시점에 적절한 메서드를 선택하는 동적 메서드 탐색을 혼합해서 동일한 메시지에 대해 서로 다른 메서드를 실행할 수 있다.
- 즉 lecture.evaluate() 이 문장 만으로 어떤 객체의 어떤 메서드가 실행되는지 알 수 없다.
- this 참조는 동적으로 정해진다.
    - ex) Lecture의 stats() 메서드
    ```
    public String stats() {
        return String.format("Title : %s, Evaluation Method : %s", title, this.getEvaluationMethod());
    }
    this.getEvaluationMethod() 에서의 this는 자기 자신인 Lecture의 메서드 가리키는것 같지만
    this.getEvaluationMethod()의 뜻은 현재 클래스의 메서드를 호출하는게 아니라 현재 객체에게 메시지를 전송하는것.
    현재 객체라는 것은 this 참조가 가리키는 객체.
    this 참조는 메시지를 수신한 객체를 가리키도록 되어 있어 this 참조가 가리키는 객체에 따라 문맥을 동적으로 바꿀 수 있다.
    ```
- 이렇게 실제로 실행될 메서드를 이해하기 위해 상속 계층을 전채적으로 이해해야하는 상황이 발생할 수 있다.
    - this 참조와 메서드 오버라이딩이 만나개 되면 어려운 코드가 만들어진다. 
       
### self 대 super
- this가 동적으로 메시지를 수신한 객체를 가리킨다면, super는 부모 클래스에서부터 메서드 탐색을 시작한다.
- super의 의도는 "부모에 정의된 메서드를 수행하라" 라는 뜻이 아닌 "부모 클래스에서 부터 메서드를 탐색하세요." 이다.
    - 부모 클래스가 아니라 더 조상일 수 있다.
- FormatterGradeLecture를 참고하자. 
    - GradeLecture에는 average()가 없지만 Lecture에는 존재하기 때문에 에러가 발생하지 않는다.
    - super 전송은 부모 클래스에서부터 탐색을 시작하는것을 잊지말자.
    - 문맥을 동적으로 결정하는것은 메시지를 수신한 객체를 가르키는 this 참조이다.

<br>
<br>

## 상속 대 위임
- 다형성은 this 참조가 가리키는 현재 객체에게 메시지를 전달하는 특성을 기반으로 한다.
    - 동일 타입의 동일 메시지를 전달하더라도 this 참조가 가리키는 객체에 따라 문맥이 달라진다.
- GradeLecture 인스턴스 입장에서 this 참조는, GradeLecture 인스턴스 자신이다.
- GradeLecture의 부모인 Lecture 입장에서 this 참조는, GradeLecture 인스턴스이다.
    - this 참조는 항상 메세지를 수신한 객체를 가리키기 때문이다.
    - 상속 계층을 구성하는 객체들 사이에서는 this 참조를 공유
- 상속은 동적으로 메서드를 탐색하기 위해 현재의 실행 문맥을 가지고 있는 this 참조를 자동으로 전달한다.
- 객체들 사이에서 메시지를 전달하는 과정이 자동으로 이뤄진다. 그래서, 자동적인 메세지 위임이라고 한다.
- 포워딩 : 객체가 다른 객체에게 요청을 처리할때 인자로 this를 전달하지 않는 경우
- 위임 : this를 전달하는 경우
